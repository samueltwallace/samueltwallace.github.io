<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="styles.css">
<title>Another LaTeX Workflow</title>
<meta name="author" content="Samuel T. Wallace">
<meta name="description" content="My LaTeX Workflow, in NeoVim.">
</head><body>

<nav>

<a href="/">Home</a>
<a href="/articles">Article Index</a>
<a href="/me/">About Me</a>

</nav>


This is a legacy post included for posterity.

<hr>

<h2>Intro</h2>
Here is my overview for LaTeX note-taking in Neovim. I will cover what plugins I use, how I've configured these plugins, and what a typical note-taking setup looks like for me, and my reflections on the setup I have. I won't cover why I use Neovim, how these plugins compare to similar ones, or really why I use the tools I use. This is meant for me to share tools in the hopes you see something you like.

<h2>Plugins</h2>

Here's my list of plugins I use for LaTeX note-taking:
<ul>
<li> <a href="UltiSnips">https://github.com/SirVer/UltiSnips/</a></li>
<li> <a href="CoC.nvim">https://github.com/neoclide/coc.nvim/</a></li>
<li> <a href="VimTeX">https://github.com/lervag/vimtex</a></li>
</ul>
Feel free to suggest alternatives or other good ones - I'm always open to them!

To break it down some more, I'll explain their function as a plugin in detail:

<h3>UltiSnips</h3>

UltiSnips is a snippet plugin. What this means is that you write out some initial text, and it gets expanded automatically to predefined text. To take an example, let's look at LaTeX for a Hello World document:

<div class="codeblock"><pre>
<p>\documentclass{article} </p><br>
<p> </p><br>
<p>\begin{document} </p><br>
<p> </p><br>
<p>Hello World! </p><br>
<p> </p><br>
<p>\end{document} </p><br>
</pre></div>

We have 4 lines of LaTeX code to show two words. It's a lot, and its necessary since LaTeX is very verbose. You can imagine how LaTeX can do worse in needing more lines for less information (like a table or something - yuck!). UltiSnips lets me write a small bit of text that could be expanded into these 4 lines, or a flexible bit of text that I can fill out fill-in-the-blank style. Let's give a small example to see how this works.

Let's say I write the following snippet:

<div class="codeblock"><pre>
<p>snippet doc "Starts a document environment" b </p><br>
<p>\documentclass{article} </p><br>
<p> </p><br>
<p>\begin{document} </p><br>
<p> </p><br>
<p>Hello World! </p><br>
<p> </p><br>
<p>\end{document} </p><br>
<p>endsnippet </p><br>
</pre></div>

This bit of code goes in a .snippets file in your UltiSnips folder with file name _filetype_.snippets where _filetype_ is the kind of file you want this snippet to work in (UltiSnips can handle this automatically with an <code>:UltiSnipsEdit</code> command). Now when we are in a _filetype_ file, we can simply type <code>doc</code> and press a predefined key to expand it into the Hello World document. 

UltiSnips is a little more flexible than this however; we can put blanks we can fill in on the fly, and have what we filled in be copied to other places. This is done with <b>tabstops</b>. Tabstops are the blanks that you can jump through with the press of a button. They can be written with a <code>$<num></code> inside a snippet, where <code><num></code> is a number. Let's look at the following example:

<div class="codeblock"><pre>
<p>snippet begin "Starts an environment" b </p><br>
<p>\begin{$1} </p><br>
<p> $0 </p><br>
<p>\end{$1} </p><br>
</pre></div>

Now when we type <code>begin</code> and press our snippet expansion key, we get

<div class="codeblock"><pre>
<p>\begin{|} </p><br>
<p> </p><br>
<p>\end{|} </p><br>
</pre></div>
Where the | is your cursor. Yes, you have a cursor in two places! And when you type, both places get get written to. This is why we have two <code>$1</code> in the snippet - the first <code>$1</code> gets written to, and the text is mirrored to every other $1. 

This is all I really want to talk about for UltiSnips, but check out the GitHub page for more information and capabilities.


<h3>CoC.nvim</h3>

This plugin (Conqueror of Completion, CoC for short) helps you find errors in your LaTeX before you've compiled. It works really well and is very fast, but was a pain for me to setup. I was messing up steps, and struggled for weeks. But eventually I got it, and I'm glad I did. It is a lifesaver. I'll mostly go over here how it works, but not go into as much of what it looks like to use, because honestly, it just gives you a little exclamation point and then will tell you the error when you move your cursor there. Not too exciting. 

This plugin works by <b>Language Server Protocol</b>, which is to say you have an additional program running in the background that checks your LaTeX without compiling. It is programmed to know the rules and find errors. It then communicates the error and its location to Neovim, which then makes the visual notification that you see. The program running the syntax checking is a server (in the technical sense) and Neovim acts as a client. The messages sent between them are in a certain format called the Language Server Protocol, a standardization made by Microsoft when they started VSCode.

This plugin runs on Node, which is a program where you can run JavaScript. So the server is run in Javascript, in Node on your own computer.

This plugin will also autocomplete your LaTeX syntax for you! You can start typing a LaTeX command and a drop down list will come up that you can select from. You can then navigate that menu with preassigned keys and select a suggestion.


<h3>VimTeX</h3>

VimTeX takes all the wonderful built-in things that ViM/Neovim can do for your code and applies it to LaTeX. This includes a command for compiling, cleanup for the pesky log files latex creates, and allows you to fold based on environment. Take a look at the screen shots on the GitHub page and see why I use it.

<h2>Configuration</h2>

Here I'm going to explain my key mappings for Vim, and the snippets I use and such. A complete collection can be found on my <a href="GitHub">https://github.com/samueltwallace/</a>. But I'll go over some useful ones.

First are some snippets. I have snippets for all the Greek letters, so <code>aa</code> maps to <code>\alpha</code>, <code>bb</code> to <code>\beta</code> and so on. I also have the begin environment I showed earlier as an example. I have lots of snippets for making equation writing nice. I auto-expand exponents and subscripts so that my exponent or subscripts goes in curly braces:

<div class="codeblock"><pre>
<p>snippet ^ "Inserts a long exponent" iA </p><br>
<p>^{ ${1:math} }$0 </p><br>
<p>usnippet </p><br>
</pre></div>

So that when I type <code>2^{2+2}<Tab></code>, I get <code>2^{2+2}</code> and my cursor is at the end of my curly braces. I do the same things with subscripts. I also autocomplete inline math environments, so that when I type a dollar sign <code>$</code>, I get the matching end dollar sign <code>$ $</code> and I can end at the end of math environment. 

I also have hte following in my .vimrc (or some equivalent in my setup)
<div class="codeblock"><pre>
<p>let g:UltiSnipsExpandTrigger="<Tab>" </p><br>
<p>let g:UltiSnipsJumpForwardTrigger="<Tab>" </p><br>
<p>let g:UltiSnipsJumpBackwardTrigger="<Shift-Tab>" </p><br>
<p>let g:UltiSnipsEditSplit="vertical" </p><br>
</pre></div>
So that I press <code><Tab></code> to expand a snippet, jump forward through tabstops, and <code><Shift+Tab></code> to go back.

Now for CoC. I have one command I use, and it is 
<code>inoremap <silent><expr> <F1> pumvisible() ? coc#_select_confirm() : "\<C-g>u\<CR>"</code>
This is only slightly modified from something on the CoC GitHub page. Now, whenever I'm in insert mode, when I hit F1, the first suggestion by CoC gets filled in.I don't currently navigate he drop down menu that much, I usually get good results with just the first result.

For VimTeX, I have a couple settings set, which slightly improve my experience. Here are my settings in my .vimrc:

<div class="codeblock"><pre>
<p>set foldmethod=expr </p><br>
<p>set foldexpr=vimtex#fold#level(v:lnum) </p><br>
<p>set foldtext=vimtex#fold#text() </p><br>
<p>nnoremap <F5> \llc </p><br>
</pre></div>

These pretty much enable folding over LaTeX environments, and let me use F5 for compiling instead of the long <code>\llc</code>.


<h2>Room for Improvement</h2>

This is certainly a start, and a good place to get comfortable before I step it up a notch with tools like regex snippets or VimTeX table of contents. I think everyone who works a lot on their LaTeX workflow aspires to Gilles Castel's <a href="legendary workflow">https://castel.dev</a>. I highly recommend looking at his workflow to see what I am aiming for. Please let me know if you have any suggestions for me!



</body>
</html>
