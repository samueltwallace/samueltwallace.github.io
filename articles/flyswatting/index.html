<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2021-07-05 Mon 16:32 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Mathematical Models of Flyswatting</title>
<meta name="generator" content="Org mode">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="../../styles.css">
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Mathematical Models of Flyswatting</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org59251a4">1. Modeling Assumptions</a></li>
<li><a href="#org2eb8738">2. Exploration of Models</a>
<ul>
<li><a href="#orgef05870">2.1. Discrete Point-Point</a></li>
<li><a href="#org1f5589c">2.2. Continuous Tracker</a></li>
<li><a href="#orgf93e107">2.3. Probabilistic Models</a></li>
</ul>
</li>
<li><a href="#org3863360">3. Future Work and Acknowledgements</a></li>
</ul>
</div>
</div>
<p>
Can you ever smash that peksy fly? Here I present five modeling assumptions for fly swatting and explore two models incorporating these assumptions and see what results we can show. I then explore potential future results in this new field.
</p>

<p>
(This is a for fun article).
</p>

<div id="outline-container-org59251a4" class="outline-2">
<h2 id="org59251a4"><span class="section-number-2">1</span> Modeling Assumptions</h2>
<div class="outline-text-2" id="text-1">
<p>
Here are five modeling assumptions for fly swatting. We tactily assume familiarity with reasonable definitions of swat, swatting object, etc.
</p>

<ul class="org-ul">
<li>(S1) The fly is 'swatted' when contact is made between the swatting object and the fly.</li>
<li>(S2) The fly position has two states: before swat and after swat, and the second is uniquely determined by the first.</li>
<li>(S3) The swatting object can be modeled by a point of impact, whereupon the fly is swatted when the fly position and swatting object point of impact position coincide.</li>
<li>(S4) The fly can be modeled by a point.</li>
<li>(S5) The swatting object and fly stay within a connected, closed bounded region of space.</li>
</ul>

<p>
Our models will proceed by assuming or not assuming the above. In the 'discrete point-point' model, we will assume all of the above. In the 'continuous tracker' model, we will assume only (S4) and replace the other assumptions by continuous analogs. We will also make mention but not explore in any depth probabilistic models for fly swatting.
</p>
</div>
</div>

<div id="outline-container-org2eb8738" class="outline-2">
<h2 id="org2eb8738"><span class="section-number-2">2</span> Exploration of Models</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-orgef05870" class="outline-3">
<h3 id="orgef05870"><span class="section-number-3">2.1</span> Discrete Point-Point</h3>
<div class="outline-text-3" id="text-2-1">
<p>
We assume (S1)-(S5). Given (S2), we have a functional a functional relationship between the before-swat position \(x\) and the post-swat position \(y\) so that \(y = F(x)\). Given (S5), we can state a domain and codomain for \(F\): if \(\Omega\) is the region of space the swatter and the fly may occupy, then \(F\) should map \(\Omega\) to itself: \(F: \Omega \to \Omega\).
</p>

<p>
Our condition for swatting is given by (S3), and we can argue for a swat condition including \(F\). Indeed, our fly is swatted if its post-swat positions aligns with the swat position. This gives the functional relationship \(x_{swatted} = F(x_{swatted})\). This gives us our first result.
</p>

<p>
<b>Theorem 1</b> Given (S1)-(S5), there is at least one point at which you can aim and successfully swat the fly. <br>
</p>


<p>
<b>Proof 1</b> By the above discussion, it suffices to find a point \(z\) which is a fixed point of \(F\). The <a href="https://en.wikipedia.org/wiki/Brouwer_fixed-point_theorem">Brouwer fixed-point</a> theorem applies, as we have a map of a connected compact domain in \(\mathbb{R}^n\) to itself. Thus we are done.
</p>

<p>
Algorithms for finding the fixed point can be solved by any multi-dimensional root-finding algorithm. Here we will explain an application of Newton's method.
</p>

<p>
<a href="https://en.wikipedia.org/wiki/Newton's_method">Newton's method</a> for systems of equations reads
</p>

\begin{equation}
z_{n+1} = z_n = J_G (z_n)^{-1} G(z_n)
\end{equation}

<p>
Where \(G: U \to U\), and \(J_G\) is the Jacobian matrix of \(G\). This algorithm finds a root of the function \(G\). By taking \(G(z) = F(z) - z\), we can find a fixed point of \(F\). However, the Jacobian of \(G\) is not known in practice: it requires perfect knowledge of the fly's movements in an open subset of a point.
</p>

<p>
We can perhaps modify this method by a linear approximation of the Jacobian at a certain point: Use instead of \(J_G(z_n)\) a matrix \(L_G(z_n, z_{n+1})\) satisfying
</p>

\begin{equation}
G(z_{n+1}) - G(z_n) = L_G(z_n, z_{n+1}) (z_n - z_{n+1})
\end{equation}

<p>
This is a multi-dimensional version of the <a href="https://en.wikipedia.org/wiki/Secant_method">secant method</a>.
</p>

<p>
Based on the computational complexity of the algorithm in mental calculations, Newton's method is not recommended in hand-to-hand encounters with flies.
</p>
</div>
</div>

<div id="outline-container-org1f5589c" class="outline-3">
<h3 id="org1f5589c"><span class="section-number-3">2.2</span> Continuous Tracker</h3>
<div class="outline-text-3" id="text-2-2">
<p>
In this model, we assume only (S4) and proceed with general discussion. Other modeling assumptions will be made reference to and included for relevant discussions.
</p>

<p>
We start by replacing (S2) with a continuous analogue: the fly has a flight path that is continuous in time. 
</p>

<p>
Without (S3), we must specify a swatting condition. A more general but still physically plausible condition is a 'rigid-body' assumption on the swatting object: the swatting object is a rigid body, whose position can be completely specified by a point and an orientation. Its shape can be encode by a region of space. We will more often use the region's indicator function. We form a body function \(B(x,y,\widehat{n})\) by the following criteria: \(B(\cdot, y, \widehat{n})\) is the indicator function of the swatting object given its position and orientation \((y, \widehat{n})\) where \(\widehat{n}\) is a unit vector. Given this, a model that qualifies a swat as simple contact between swatting object and fly seems easiest and still physically plausible.
</p>

<p>
Now given a swatting object, we must now describe its swatting action. Indeed, now given a continuous-time model, we cannot simple assume one instant of slap with a single point of impact. Instead, we may develop a path of motion for the swatting object for it to follow towards the fly. One candidate is the 'tracker' path. Let \(x(t)\) be the path of the fly. Then the path of the body position and orientation is given by
</p>

\begin{equation}
\frac{dy}{dt}(t) = s_0 \frac{x(t) - y(t)}{\vert x(t) - y(t) \vert} 
\end{equation}
\begin{equation}
\frac{d \widehat{n}}{dt} = \frac{x(t) - y(t)}{\vert x(t) - y(t) \vert}
\end{equation}

<p>
i.e., the swatting object moves at a constant speed \(s_0\) towards the fly, oriented directly at it. This is a conceptually simple model.
</p>

<p>
Results remain wide open with these assumptions. No results are known to the author.
</p>

<p>
Other tracking equations are possible, and possibly more valid depending on the swatting object and the swatting application in mind.
</p>
</div>
</div>

<div id="outline-container-orgf93e107" class="outline-3">
<h3 id="orgf93e107"><span class="section-number-3">2.3</span> Probabilistic Models</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Even more sophisticated models are possible. One may evolve the fly path according to a probabilistic path; i.e. a stochastic process. A probabilistic tracker may follow a 'highest-likelihood' trajectory: follow the point at any given time where the fly is most likely to be. These models incorporate the seemingly random movements of flies as they fly.
</p>
</div>
</div>
</div>

<div id="outline-container-org3863360" class="outline-2">
<h2 id="org3863360"><span class="section-number-2">3</span> Future Work and Acknowledgements</h2>
<div class="outline-text-2" id="text-3">
<p>
Currently very little is known about fly-swatting problems in the knowledge of the author. Very likely tracking algorithms can be developed from known results in dynamics and controls results.
</p>

<p>
Feedback and contributions are always welcome; submit an issue or pull request at <a href="https://github.com/samueltwallace/samueltwallace.github.io">GitHub</a>.
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2021-07-05 Mon 16:32</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
